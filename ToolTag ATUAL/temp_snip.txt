                    except Exception:
                        pass
                    counts = Counter([(it.get('prioridade') or 'baixa').lower() for it in filtered])
                    if counts:
                        labels = list(counts.keys())
                        values = [counts[l] for l in labels]
                        fig, ax = plt.subplots(figsize=(6.2, 3.8), dpi=150)
                        fig.patch.set_facecolor('white')
                        ax.set_facecolor('white')
                        palette = ['#27ae60', '#f1c40f', '#e67e22', '#e74c3c', '#8e44ad', '#3498db']
                        colors = [palette[i % len(palette)] for i in range(len(labels))]
                        bars = ax.bar(labels, values, color=colors, edgecolor='none')
                        # Valores no topo de cada barra
                        for bar in bars:
                            height = bar.get_height()
                            ax.annotate(f'{int(height)}',
                                        xy=(bar.get_x() + bar.get_width() / 2, height),
                                        xytext=(0, 6),
                                        textcoords='offset points',
                                        ha='center', va='bottom', fontsize=9, color='#2c3e50')
                        # Eixos e grade sutis
                        for spine in ['top', 'right']:
                            ax.spines[spine].set_visible(False)
                        ax.grid(True, axis='y', linestyle='--', alpha=0.25)
                        ax.set_axisbelow(True)
                        ax.set_title('Itens por Prioridade', fontsize=12, color='#2c3e50', pad=10)
                        ax.set_xlabel('Prioridade', fontsize=10)
                        ax.set_ylabel('Quantidade', fontsize=10)
                        fig.tight_layout()
                        import io as _io
                        img_buf = _io.BytesIO()
                        plt.savefig(img_buf, format='png', dpi=160)
                        plt.close(fig)
                        img_buf.seek(0)
                        img = ImageReader(img_buf)
                        c.showPage()
                        c.drawImage(img, 40, 160, width=520, height=380, preserveAspectRatio=True)
                except Exception:
                    pass

                c.save(); buf.seek(0)
                return send_file(buf, as_attachment=True, download_name='relatorio_ocorrencias.pdf', mimetype='application/pdf')
            except Exception as e:
                logger.error(f"Falha ao gerar PDF: {str(e)}")
                return make_response("Instale dependências: pip install reportlab matplotlib", 500)
        except Exception as e:
            logger.error(f"Erro no relatório: {str(e)}")
            return make_response(f"Erro ao gerar relatório: {str(e)}", 500)

@app.route('/cadastro')
def cadastro():
    logger.info("Rendering cadastro.html")
    return render_template('cadastro.html')

@app.route('/cadastro', methods=['POST'])
def cadastro_post():
    with db_lock:
        with app.app_context():  # Ensure application context
            conn = None
            try:
                conn = get_db_connection()
                cursor = conn.cursor()
                tipo_item = request.form.get('tipo_item')
                codigo_interno = request.form.get('codigo_interno', '').strip()
                nome_descricao = request.form.get('nome_descricao', '').strip()
                
                if not tipo_item or not codigo_interno or not nome_descricao:
                    conn.close()
                    logger.error("Missing required fields in cadastro")
                    return jsonify({'message': 'Por favor, preencha todos os campos obrigatórios.'}), 400
                
                if len(codigo_interno) < 2 or len(nome_descricao) < 3:
                    conn.close()
                    logger.error("Invalid input length for codigo_interno or nome_descricao")
                    return jsonify({'message': 'Código interno deve ter pelo menos 2 caracteres e nome/descrição pelo menos 3 caracteres.'}), 400
                
                cursor.execute('SELECT id FROM itens_cadastro WHERE lower(codigo_interno) = lower(?)', (codigo_interno,))
                if cursor.fetchone():
                    conn.close()
                    logger.error(f"Código interno {codigo_interno} já existe")
                    return jsonify({'message': 'Código interno já existe! Use um código diferente.'}), 400
                
                altura_min = request.form.get('altura_min')
                altura_min = float(altura_min) if altura_min and altura_min.strip() else None
                altura_max = request.form.get('altura_max')
                altura_max = float(altura_max) if altura_max and altura_max.strip() else None
                if altura_max is not None and altura_min is not None and altura_min > altura_max:
                    conn.close()
                    logger.error("Altura mínima maior que altura máxima")
                    return jsonify({'message': 'Altura mínima não pode ser maior que altura máxima.'}), 400
                
                rpm = request.form.get('rpm')
                rpm = int(rpm) if rpm and rpm.strip() else None
                avanco = request.form.get('avanco')
                avanco = float(avanco) if avanco and avanco.strip() else None
                
                categoria = request.form.get('categoria')
                categoria = categoria if categoria and categoria.strip() else None
                material = request.form.get('material')
                material = material if material and material.strip() else None
                
                foto_filename = None
                if 'foto' in request.files:
                    file = request.files['foto']
                    if file and file.filename != '' and allowed_file(file.filename):
                        if not os.path.exists(app.config['UPLOAD_FOLDER']):
                            os.makedirs(app.config['UPLOAD_FOLDER'])
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        filename = f"{codigo_interno}_{timestamp}_{secure_filename(file.filename)}"
                        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                        file.save(filepath)
                        foto_filename = filename
                    elif file and file.filename != '':
                        conn.close()
                        logger.error("Invalid file format for foto")
                        return jsonify({'message': 'Formato de arquivo inválido. Use: PNG, JPG, JPEG, GIF, WEBP.'}), 400
                
                # Tipo de máquina (apenas para ferramenta)
                maquina = None
                if tipo_item == 'ferramenta':
                    maquina = request.form.get('ferramenta_tipo') or request.form.get('maquina') or None
                    if maquina:
                        maquina = maquina.strip() or None

                cursor.execute('''
                    INSERT INTO itens_cadastro (
                        tipo_item, codigo_fabricacao, codigo_interno, nome_descricao,
                        foto, categoria, material, maquina, altura_min, altura_max, rpm, avanco, data_cadastro
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    tipo_item,
                    request.form.get('codigo_fabricacao', ''),
                    codigo_interno,
                    nome_descricao,
                    foto_filename,
                    categoria,
                    material,
                    maquina,
                    altura_min,
                    altura_max,
                    rpm,
                    avanco,
                    datetime.now().strftime('%d/%m/%Y %H:%M')
                ))
                
                ferramenta_id = cursor.lastrowid
                
                if tipo_item == 'ferramenta':
                    insumos_ids = request.form.getlist('composicao_insumos')
                    quantidades = request.form.getlist('composicao_quantidades')
                    
                    if not insumos_ids:
                        conn.close()
                        logger.error("Ferramentas devem ter pelo menos um insumo na composição")
                        return jsonify({'message': 'Ferramentas devem ter pelo menos um insumo na composição.'}), 400
                    
                    for i, insumo_id in enumerate(insumos_ids):
                        if insumo_id and insumo_id.isdigit():
                            quantidade = int(quantidades[i]) if i < len(quantidades) and quantidades[i].isdigit() else 1
                            if quantidade <= 0:
                                conn.close()
                                logger.error("Invalid insumo quantity")
                                return jsonify({'message': 'Quantidade de insumo deve ser maior que zero.'}), 400
                            cursor.execute('''
                                INSERT INTO composicao_ferramentas (ferramenta_id, insumo_id, quantidade)
                                VALUES (?, ?, ?)
                            ''', (ferramenta_id, int(insumo_id), quantidade))
                
                conn.commit()
                conn.close()
                logger.info(f"Item {ferramenta_id} cadastrado com sucesso: {tipo_item}")
                return jsonify({'message': f'{tipo_item.title()} cadastrado(a) com sucesso!'})
                
            except sqlite3.IntegrityError as e:
                if conn is not None:
                    conn.close()
                logger.error(f"Erro de integridade ao cadastrar item: {str(e)}")
                return jsonify({'message': 'Código interno já existe! Use um código diferente.'}), 400
            except ValueError as e:
                if conn is not None:
                    conn.close()
                logger.error(f"Erro de validação ao cadastrar item: {str(e)}")
                return jsonify({'message': f'Erro de validação: {str(e)}'}), 400
            except Exception as e:
                if conn is not None:
                    conn.rollback()
                    conn.close()
                logger.error(f"Erro inesperado ao cadastrar item: {str(e)}")
                return jsonify({'message': f'Erro ao cadastrar: {str(e)}'}), 500

@app.route('/api/verificar_codigo_interno', methods=['GET'])
def verificar_codigo_interno():
    codigo = request.args.get('codigo')
    if not codigo or not isinstance(codigo, str) or codigo.strip() == '':
        logger.error("Código interno inválido ou não fornecido")
        return jsonify({"error": "Código interno inválido ou não fornecido"}), 400
    
    with app.app_context():  # Ensure application context
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT 1 FROM itens_cadastro WHERE lower(codigo_interno) = lower(?)', (codigo,))
            exists = cursor.fetchone() is not None
            conn.close()
            logger.info(f"Verificação de código interno {codigo}: {'existe' if exists else 'não existe'}")
            return jsonify({"exists": exists})
        except sqlite3.Error as e:
            logger.error(f"Erro ao verificar código interno: {str(e)}")
            return jsonify({"error": f"Erro no banco de dados: {str(e)}"}), 500

@app.route('/gestao', methods=['GET', 'POST'])
def gestao():
    if not session.get('gestao_logged'):
        return redirect(url_for('login'))
    with app.app_context():  # Ensure application context
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT i.*, ic.nome_descricao AS nome_item FROM insumos i LEFT JOIN itens_cadastro ic ON i.item_id = ic.id ORDER BY i.id DESC LIMIT 5')
            insumos_recentes = [dict(row) for row in cursor.fetchall()]
            cursor.execute('SELECT * FROM ocorrencias ORDER BY id DESC LIMIT 5')
            ocorrencias_recentes = [dict(row) for row in cursor.fetchall()]
            cursor.execute('SELECT COUNT(*) FROM insumos')
            total_insumos = cursor.fetchone()[0]
            cursor.execute('SELECT COUNT(*) FROM ocorrencias')
            total_ocorrencias = cursor.fetchone()[0]
            cursor.execute('SELECT COUNT(*) FROM itens_cadastro')
            total_itens_cadastro = cursor.fetchone()[0]
            conn.close()
            logger.info(f"Rendering gestao.html com {total_insumos} insumos, {total_ocorrencias} ocorrências, {total_itens_cadastro} itens")
            return render_template('gestao.html', 
                                total_insumos=total_insumos,
                                total_ocorrencias=total_ocorrencias,
                                total_itens_cadastro=total_itens_cadastro,
                                insumos_recentes=insumos_recentes,
                                ocorrencias_recentes=ocorrencias_recentes)
        except sqlite3.Error as e:
            logger.error(f"Erro ao carregar página de gestão: {str(e)}")
            return render_template('error.html', code=500, message=f"Erro no banco de dados: {str(e)}"), 500

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = (request.form.get('gestao_username') or request.form.get('username') or '').strip()
        password = (request.form.get('gestao_password') or request.form.get('password') or '').strip()
        next_url = (request.form.get('next') or request.args.get('next') or '').strip()
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT username, password FROM admin LIMIT 1')
            row = cursor.fetchone()
            conn.close()
            if row and username == row['username'] and password == row['password']:
                session['gestao_logged'] = True
                session['gestao_user'] = username
                # Redireciona para o destino requisitado (ocorrencias/gestao/etc.)
                if next_url and next_url.startswith('/'):
                    return redirect(next_url)
                return redirect(url_for('gestao'))
            else:
                return render_template('login.html', error='Usuário ou senha inválidos')
        except Exception as e:
            logger.error(f"Erro no login: {str(e)}")
            return render_template('login.html', error='Erro ao processar login')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

@app.route('/logout_beacon', methods=['POST'])
def logout_beacon():
    try:
        session.clear()
        return ('', 204)
    except Exception:
        return ('', 204)

@app.route('/gestao/reset', methods=['GET', 'POST'])
def gestao_reset():
    if request.method == 'POST':
        fab_login = request.form.get('fab_login', '').strip()
        fab_password = request.form.get('fab_password', '').strip()
        new_user = request.form.get('new_username', '').strip()
        new_pass = request.form.get('new_password', '').strip()

        if fab_login != 'TOOLTAG' or fab_password != '7001749':
            return render_template('reset_gestao.html', error='Credenciais do fabricante inválidas')
        if not new_user or not new_pass:
            return render_template('reset_gestao.html', error='Informe novo usuário e nova senha')

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT id FROM admin LIMIT 1')
            row = cursor.fetchone()
            if row:
                cursor.execute('UPDATE admin SET username = ?, password = ? WHERE id = ?', (new_user, new_pass, row['id']))
            else:
                cursor.execute('INSERT INTO admin (username, password) VALUES (?, ?)', (new_user, new_pass))
            conn.commit()
            conn.close()
            return render_template('reset_gestao.html', success='Usuário e senha atualizados com sucesso')
        except Exception as e:
            logger.error(f"Erro ao redefinir credenciais: {str(e)}")
            return render_template('reset_gestao.html', error='Erro ao atualizar credenciais')

    return render_template('reset_gestao.html')

# REMOVIDA a rota /visualocorrencia

@app.route('/visualinsumo')
def visual_insumo():
    id = request.args.get('id')
    logger.info(f"Acessando visualinsumo com id={id}")
    if not id or not id.isdigit():
        logger.error("ID de insumo inválido")
        return jsonify({'error': 'ID de insumo inválido'}), 400
    
    with app.app_context():  # Ensure application context
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT i.*, ic.nome_descricao AS nome_item FROM insumos i LEFT JOIN itens_cadastro ic ON i.item_id = ic.id WHERE i.id = ?', (id,))
            insumo = cursor.fetchone()
            conn.close()
            
            if not insumo:
                logger.error(f"Insumo com id={id} não encontrado")
                return jsonify({'error': 'Insumo não encontrado'}), 404
            
            logger.info(f"Insumo encontrado: {dict(insumo)}")
            # Agora usar o HTML modificado para atender insumo
            return render_template('atender_insumo.html', insumo=dict(insumo))
        except Exception as e:
            logger.error(f"Erro na rota /visualinsumo: {str(e)}")
            return jsonify({'error': f'Erro interno: {str(e)}'}), 500

# Nova rota para API de insumo específico
@app.route('/api/insumo/<int:id>', methods=['GET'])
def get_insumo(id):
    with app.app_context():
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT i.*, ic.nome_descricao AS nome_item FROM insumos i LEFT JOIN itens_cadastro ic ON i.item_id = ic.id WHERE i.id = ?', (id,))
            insumo = cursor.fetchone()
            conn.close()
            
            if not insumo:
                logger.error(f"Insumo com id={id} não encontrado")
                return jsonify({"error": "Insumo não encontrado"}), 404
            
            insumo_dict = dict(insumo)
            # Converter fotos de JSON string para lista se existir
            if insumo_dict.get('fotos'):
                try:
                    insumo_dict['fotos'] = json.loads(insumo_dict['fotos'])
                except:
                    insumo_dict['fotos'] = []
            else:
                insumo_dict['fotos'] = []
                
            logger.info(f"Insumo retornado para id={id}: {insumo_dict}")
            return jsonify(insumo_dict)
        except sqlite3.Error as e:
            logger.error(f"Erro ao obter insumo id={id}: {str(e)}")
            return jsonify({"error": str(e)}), 500

# Nova rota para atender insumo (salvar fotos e atualizar status)
@app.route('/api/insumo/<int:id>/atender', methods=['PUT'])
def atender_insumo(id):
    with db_lock:
        with app.app_context():
            conn = None
            try:
                conn = get_db_connection()
                cursor = conn.cursor()
                
                # Verificar se o insumo existe
